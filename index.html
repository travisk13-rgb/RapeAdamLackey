<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>St. Patrick's Day Countdown</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="A simple New Year countdown with floating media. Drop this folder into Netlify to deploy." />
  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <!-- BACKGROUND VIDEO -->
  <div class="bg-video-wrap">
    <video src="media/vid1.mp4" autoplay muted loop playsinline></video>
  </div>
  
  <div class="bg-overlay"></div>

  <!-- FLOATING MEDIA (BACKDROP) -->
  <div class="floating-backdrop">
    <!-- floating items will be injected here from media/manifest.json -->
  </div>

  <!-- HERO / COUNTDOWN (fixed) -->
  <div class="countdown-wrapper" aria-hidden="false">
    <div class="center">
      <h1>Countdown to <span id="year"></span> üçÄ St. Patrick's Day</h1>

      <div class="countdown">
        <div class="time-box">
          <span id="days" class="time-value">0</span>
          <span class="label">Days</span>
        </div>
        <div class="time-box">
          <span id="hours" class="time-value">00</span>
          <span class="label">Hours</span>
        </div>
        <div class="time-box">
          <span id="minutes" class="time-value">00</span>
          <span class="label">Minutes</span>
        </div>
        <div class="time-box">
          <span id="seconds" class="time-value">00</span>
          <span class="label">Seconds</span>
        </div>
      </div>

      <p id="message"></p>
    </div>
  </div>

  <!-- SCROLLABLE CONTENT (gallery, offers, info) -->
  <main class="content-section">
    <section class="gallery">
      <h2>St. Patrick's Day Specials</h2>
      <div class="content-gallery"></div>
    </section>

    <section class="offers">
      <h2>Funny Savings</h2>
      <p>Add your offers or content here. Scroll down to see more images and content while the countdown remains fixed above.</p>
    </section>
  </main>

  <script>
    // St. Patrick's Day Countdown
    (function () {
      function getNextStPatricksYear() {
        const now = new Date();
        const year = now.getFullYear();
        const thisYearTarget = new Date(`March 17, ${year} 00:00:00`);
        if (now < thisYearTarget) return year;
        return year + 1;
      }

      let targetYear = getNextStPatricksYear();
      const target = () => new Date(`March 17, ${targetYear} 00:00:00`);

      document.getElementById("year").textContent = targetYear;

      function updateCountdown() {
        const now = new Date();
        let t = target();
        if (now > t) {
          targetYear = getNextStPatricksYear();
          document.getElementById("year").textContent = targetYear;
        }
        const diff = t - now;
        if (diff <= 0) {
          document.getElementById("message").textContent = "üçÄ Happy St. Patrick's Day!";
          return;
        }
        const s = Math.floor(diff / 1000);
        document.getElementById("days").textContent = Math.floor(s / 86400);
        document.getElementById("hours").textContent = String(Math.floor(s % 86400 / 3600)).padStart(2, "0");
        document.getElementById("minutes").textContent = String(Math.floor(s % 3600 / 60)).padStart(2, "0");
        document.getElementById("seconds").textContent = String(s % 60).padStart(2, "0");
      }

      updateCountdown();
      setInterval(updateCountdown, 1000);
    })();

      // Load manifest (floating items + gallery) then init animated floating items
      (function () {
        function createFloatItem(src, opts = {}) {
          const item = document.createElement('div');
          item.className = 'float-item';
          if (opts.speed) item.dataset.speed = opts.speed;
          // use inline percent if provided
          if (opts.top) item.style.top = opts.top;
          if (opts.left) item.style.left = opts.left;
          if (opts.right) item.style.right = opts.right;
          if (opts.bottom) item.style.bottom = opts.bottom;
          const inner = document.createElement('div'); inner.className = 'float-inner';
            // check if file is video (simple heuristic: ends with video extension)
            const isVideo = /\.(mp4|webm|ogg|mov)$/i.test(src);
            if (isVideo) {
              const vid = document.createElement('video');
              vid.src = 'media/' + src;
              vid.autoplay = true;
              vid.muted = true;
              vid.loop = true;
              vid.playsinline = true;
              vid.style.width = '100%';
              vid.style.height = '100%';
              vid.style.objectFit = 'contain';
              vid.style.display = 'block';
              inner.appendChild(vid);
            } else {
              const img = document.createElement('img');
              img.src = 'media/' + src;
              img.alt = opts.alt || src;
              inner.appendChild(img);
            }
            item.appendChild(inner);
          document.querySelector('.floating-backdrop').appendChild(item);
        }

        function addGalleryItem(src) {
          const gallery = document.querySelector('.content-gallery');
          if (!gallery) return;
          const wrap = document.createElement('div'); wrap.className = 'gallery-item';
          const img = document.createElement('img'); img.src = 'media/' + src; img.alt = src;
          wrap.appendChild(img); gallery.appendChild(wrap);
        }

        // fetch manifest; if missing, fall back to existing files
        fetch('media/manifest.json').then(resp => resp.json()).then(manifest => {
          (manifest.floating || []).forEach(f => createFloatItem(f.file, f.opts || {}));
          (manifest.gallery || []).forEach(g => addGalleryItem(g));
          // after injecting, initialize physics
          initFloatingPhysics();
        }).catch(() => {
          // fallback: use default known files
          ['1.PNG','3.png','2.JPG'].forEach((f,i)=> createFloatItem(f, { speed: [0.18,0.30,0.22][i] }));
          initFloatingPhysics();
        });

        // physics initializer (moved into a function so we run after manifest load)
        function initFloatingPhysics() {
          const items = Array.from(document.querySelectorAll('.floating-backdrop .float-item'));
          const state = items.map((el, i) => {
            const rect = el.getBoundingClientRect();
            // initialize if inline styles not set
            const left = parseFloat(el.style.left) || rect.left || (20 + i * 120);
            const top = parseFloat(el.style.top) || rect.top || (20 + i * 80);
            // clear left/top for transform-based positioning
            el.style.left = '0px'; el.style.top = '0px';
            return {
              el,
              x: left,
              y: top,
              vx: (Math.random() * 1.2 - 0.6) * 0.6,
              vy: (Math.random() * 1.2 - 0.6) * 0.6,
              w: el.offsetWidth || 220,
              h: el.offsetHeight || 220,
              speed: parseFloat(el.dataset.speed) || 0.2
            };
          });

          let mouse = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
          window.addEventListener('mousemove', (e) => { mouse.x = e.clientX; mouse.y = e.clientY; });
          window.addEventListener('resize', () => { state.forEach(s => { s.w = s.el.offsetWidth; s.h = s.el.offsetHeight; }); });

          function step() {
            const scrollY = window.scrollY || 0;
            const width = window.innerWidth;
            const height = window.innerHeight;

            state.forEach(s => {
              // apply slight attraction/repulsion to mouse
              const dx = (mouse.x - (s.x + s.w / 2));
              const dy = (mouse.y - (s.y + s.h / 2));
              const dist = Math.sqrt(dx*dx + dy*dy) + 0.001;
              const force = Math.max(0, 120 - dist) / 120; // closer => stronger
              s.vx += (dx / dist) * force * 0.06;
              s.vy += (dy / dist) * force * 0.06;

              // friction
              s.vx *= 0.985;
              s.vy *= 0.985;

              // move
              s.x += s.vx + (scrollY * 0.001 * s.speed);
              s.y += s.vy + (scrollY * 0.001 * s.speed);

              // bounce inside viewport with margin so items remain visible
              const margin = 24;
              if (s.x < margin) { s.x = margin; s.vx = Math.abs(s.vx) * 0.7; }
              if (s.y < margin) { s.y = margin; s.vy = Math.abs(s.vy) * 0.7; }
              if (s.x + s.w > width - margin) { s.x = width - s.w - margin; s.vx = -Math.abs(s.vx) * 0.7; }
              if (s.y + s.h > height - margin) { s.y = height - s.h - margin; s.vy = -Math.abs(s.vy) * 0.7; }

              // apply transform
              s.el.style.transform = `translate3d(${s.x}px, ${s.y}px, 0)`;
            });

            requestAnimationFrame(step);
          }

          // make sure hero sits above the backdrop
          document.querySelector('.hero').style.position = 'relative';
          document.querySelector('.hero').style.zIndex = 2;

          requestAnimationFrame(step);
        }
      })();
  </script>
  <script>
    // Ensure page content doesn't scroll under the fixed countdown.
    (function () {
      function syncCountdownSpacing() {
        const cw = document.querySelector('.countdown-wrapper');
        if (!cw) return;
        // get height and apply as body padding-top so content starts below countdown
        const h = Math.ceil(cw.getBoundingClientRect().height);
        document.body.style.paddingTop = h + 'px';
      }
      window.addEventListener('load', syncCountdownSpacing);
      window.addEventListener('resize', syncCountdownSpacing);
      // call early in case DOM already loaded
      setTimeout(syncCountdownSpacing, 50);
    })();
  </script>
</body>
</html>
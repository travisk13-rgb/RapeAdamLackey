<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>St. Patrick's Day Countdown</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="A simple New Year countdown with floating media. Drop this folder into Netlify to deploy." />
  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <!-- BACKGROUND VIDEO -->
  <div class="bg-video-wrap">
    <video src="media/vid1.mp4" autoplay muted loop playsinline></video>
  </div>
  
  <div class="bg-overlay"></div>

  <!-- FLOATING MEDIA (BACKDROP) -->
  <div class="floating-backdrop">
    <!-- 1.PNG -->
    <div class="float-item" data-speed="0.18" style="top: 8%; left: 5%;">
      <div class="float-inner">
        <img src="media/1.PNG" alt="">
      </div>
    </div>

    <!-- 3.png -->
    <div class="float-item" data-speed="0.30" style="top: 20%; right: 8%;">
      <div class="float-inner">
        <img src="media/3.png" alt="">
      </div>
    </div>

    <!-- 2.JPG -->
    <div class="float-item" data-speed="0.22" style="bottom: 15%; left: 10%;">
      <div class="float-inner">
        <img src="media/2.JPG" alt="">
      </div>
    </div>
  </div>

  <!-- HERO / COUNTDOWN -->
  <section class="hero">
    <div class="center">
      <h1>Countdown to <span id="year"></span> üçÄ St. Patrick's Day</h1>

      <div class="countdown">
        <div class="time-box">
          <span id="days" class="time-value">0</span>
          <span class="label">Days</span>
        </div>
        <div class="time-box">
          <span id="hours" class="time-value">00</span>
          <span class="label">Hours</span>
        </div>
        <div class="time-box">
          <span id="minutes" class="time-value">00</span>
          <span class="label">Minutes</span>
        </div>
        <div class="time-box">
          <span id="seconds" class="time-value">00</span>
          <span class="label">Seconds</span>
        </div>
      </div>

      <p id="message"></p>
    </div>
  </section>

  <script>
    // St. Patrick's Day Countdown
    (function () {
      function getNextStPatricksYear() {
        const now = new Date();
        const year = now.getFullYear();
        const thisYearTarget = new Date(`March 17, ${year} 00:00:00`);
        if (now < thisYearTarget) return year;
        return year + 1;
      }

      let targetYear = getNextStPatricksYear();
      const target = () => new Date(`March 17, ${targetYear} 00:00:00`);

      document.getElementById("year").textContent = targetYear;

      function updateCountdown() {
        const now = new Date();
        let t = target();
        if (now > t) {
          targetYear = getNextStPatricksYear();
          document.getElementById("year").textContent = targetYear;
        }
        const diff = t - now;
        if (diff <= 0) {
          document.getElementById("message").textContent = "üçÄ Happy St. Patrick's Day!";
          return;
        }
        const s = Math.floor(diff / 1000);
        document.getElementById("days").textContent = Math.floor(s / 86400);
        document.getElementById("hours").textContent = String(Math.floor(s % 86400 / 3600)).padStart(2, "0");
        document.getElementById("minutes").textContent = String(Math.floor(s % 3600 / 60)).padStart(2, "0");
        document.getElementById("seconds").textContent = String(s % 60).padStart(2, "0");
      }

      updateCountdown();
      setInterval(updateCountdown, 1000);
    })();

    // Animated floating items with basic physics (bounce + mouse influence)
    (function () {
      const items = Array.from(document.querySelectorAll('.floating-backdrop .float-item'));

      function parsePositionValue(val, axisSize) {
        if (!val) return null;
        val = val.trim();
        if (val.endsWith('%')) {
          return parseFloat(val) / 100 * axisSize;
        }
        if (val.endsWith('px')) return parseFloat(val);
        // plain number
        if (!isNaN(parseFloat(val))) return parseFloat(val);
        return null;
      }

      const state = items.map((el, i) => {
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        const cs = getComputedStyle(el);

        // determine initial x/y in pixels from left/right/top/bottom (supports %)
        let x = null, y = null;
        const leftVal = cs.left;
        const rightVal = cs.right;
        const topVal = cs.top;
        const bottomVal = cs.bottom;
        if (leftVal && leftVal !== 'auto') x = parsePositionValue(leftVal, vw);
        else if (rightVal && rightVal !== 'auto') { const v = parsePositionValue(rightVal, vw); if (v!=null) x = vw - v - el.offsetWidth; }
        if (topVal && topVal !== 'auto') y = parsePositionValue(topVal, vh);
        else if (bottomVal && bottomVal !== 'auto') { const v = parsePositionValue(bottomVal, vh); if (v!=null) y = vh - v - el.offsetHeight; }

        // fallback to random if not provided
        if (x == null) x = Math.random() * (vw - el.offsetWidth - 48) + 24;
        if (y == null) y = Math.random() * (vh - el.offsetHeight - 48) + 24;

        // reset left/top to 0 to avoid double-layout; we'll position via transform
        el.style.left = '0px';
        el.style.top = '0px';

        return {
          el,
          x,
          y,
          vx: (Math.random() * 1.2 - 0.6) * 0.8,
          vy: (Math.random() * 1.2 - 0.6) * 0.8,
          w: el.offsetWidth || 220,
          h: el.offsetHeight || 220,
          speed: parseFloat(el.dataset.speed) || 0.2
        };
      });

      let mouse = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
      window.addEventListener('mousemove', (e) => { mouse.x = e.clientX; mouse.y = e.clientY; });
      window.addEventListener('resize', () => { state.forEach(s => { s.w = s.el.offsetWidth; s.h = s.el.offsetHeight; }); });

      function step() {
        const scrollY = window.scrollY || 0;
        const width = window.innerWidth;
        const height = window.innerHeight;

        state.forEach(s => {
          // attraction to mouse within a radius, weaker effect
          const cx = s.x + s.w/2;
          const cy = s.y + s.h/2;
          const dx = mouse.x - cx;
          const dy = mouse.y - cy;
          const dist = Math.sqrt(dx*dx + dy*dy) + 0.0001;
          const radius = Math.max(120, Math.min(300, Math.max(s.w,s.h)));
          const force = Math.max(0, (radius - dist) / radius) * 0.04; // tuned
          s.vx += (dx/dist) * force;
          s.vy += (dy/dist) * force;

          // gentle random wandering
          s.vx += (Math.random()-0.5) * 0.02;
          s.vy += (Math.random()-0.5) * 0.02;

          // friction
          s.vx *= 0.98;
          s.vy *= 0.98;

          // move + small scroll influence
          s.x += s.vx + (scrollY * 0.0006 * s.speed);
          s.y += s.vy + (scrollY * 0.0006 * s.speed);

          // bounce inside viewport with margin so items remain visible
          const margin = 12;
          if (s.x < margin) { s.x = margin; s.vx = Math.abs(s.vx) * 0.7; }
          if (s.y < margin) { s.y = margin; s.vy = Math.abs(s.vy) * 0.7; }
          if (s.x + s.w > width - margin) { s.x = width - s.w - margin; s.vx = -Math.abs(s.vx) * 0.7; }
          if (s.y + s.h > height - margin) { s.y = height - s.h - margin; s.vy = -Math.abs(s.vy) * 0.7; }

          // apply transform (keep within viewport)
          s.el.style.transform = `translate3d(${s.x}px, ${s.y}px, 0)`;
        });

        requestAnimationFrame(step);
      }

      // ensure hero is above backdrop
      const hero = document.querySelector('.hero');
      if (hero) { hero.style.position = 'relative'; hero.style.zIndex = 2; }

      requestAnimationFrame(step);
    })();
  </script>
</body>
</html>